# 字符串的扩展
这一章懂的内容比较不好理解 但是也是需要学习的。

JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。

    Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码

    方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。

    1990年研发，1994年发布。

    1、美国人首先对其英文字符进行了编码，也就是最早的ascii码，用一个字节的低7位来表示英文的128个字符，高1位统一为0； 

    2、后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普
    
    遍使用一个全字节进行编码，最多可表示256位。欧美人就是喜欢直来直去，字符少，编码用得位数少； 

    3、但是即使位数少，不同国家地区用不同的字符编码，虽然0--127表示的符号是一样的，但是128--255这一段的解释完全乱套了，即使2进
    
    制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号； 

    4、更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这
    
    些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得
    
    到，但是电脑上如果不处理一下你是显示不出来的了吧。 

    5、这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，尼玛显示都是乱码啊。为了统一，于是就
    
    发明了unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符
    
    号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。


    带来的问题

    Unicode定义了所有符号的二进制形式，也就是符号如何在计算机内部存储的，而且每个符号规定都必须使用两个字节来表示，
    
    也就是用16位二进制去代表一个符号，
    
    这样就导致了一个问题，英文编码的空间浪费，因为在ANSI中的符号都是一个字节来表示的，而使用了UNICODE编码就白白浪费了一个字节。
    
    也就代表着Unicode需要使用两倍的空间去存储相应的ANSI编码下的符号。

    
    虽然现在硬盘或者内存都很廉价，但是在网络传输中，这个问题就凸显出来了，你可以这样想想，本来1M的带宽在ANSI下可以代表
    
    1024*1024个字符，但是在Unicode下却只能代表1024*1024/2个字符。也就是1MB/s的带宽只能等价于512KB/s，这个很可怕啊。所以为了
    
    解决符号在网络中传输的浪费问题，就出现了UTF-8编码，Unicode transfer format -8 ，后面的8代表是以8位二进制为单位来传输符号
    
    的，但是这样又导致了一个问题，虽然UTF-8可以使用一个字节来表示ANSI下的符号，但是对于其它类似汉语的符号，得需要两个字节来表
    
    示，所以计算机不知道如何去截取一个符号，也就是一个符号对应的二进制的截取开始位置和截取结束位置。所以为了解决Unicode下的ANSI
    
    符号的空间浪费和网络传输下如何截取字符的问题，UTF规定：如果一个符号只占一个字节，那么这个8位字节的第一位就为0。如果为两个字
    
    节，那么规定第一个字节的前两位都为1，然后第一个字节的第三位为0，第二个字节的前两位为10，然后如果是三个字节的话，那么第一个
    
    字节的前三位为111，第四位为0，剩余的两个字节的前两位都为10。按照这样的算法去思考一个中文字符的UTF-8是怎么表示的：一个中文字
    
    符需要两个字节来表示，两个字节一共是16位，那么UTF-8下，两个字节是不够的，因为两个字节下，第一个字节已经占据了三位：110，然
    
    后剩余的一个字节占据了两位：10，现在就只剩下8位，与Unicode下的两个字节，18位去表示任意一个字符是相悖的，也就是Unicode下的
    
    18位减去UTF-8下的8位=8位，刚好差了一个字节的空间，所以就使用三个字节去表示非ANSI字符：三个字节下，一共是24位，第一个字节头
    
    四位是：1110，后两个字节的前两位都是：10，那么24位-8位=16位，刚好两个字节去表示Unicode下的任意一个非ANSI字符。这也就是为
    
    什么UTF-8需要使用三个字节去表示一个非ANSI字符的原因了！
```js
"\u0061"
// "a"
```

这种表示法只限于码点在\u0000~\uFFFF (0-65535) 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 

```js
"\uD842\uDFB7"
// "𠮷"

"\u20BB7" 
// " 7"
```
上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
```js
"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
```
上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。
```js
'\z' === 'z' // true 转义字符
'\172' === 'z' //true ASCII 码
'\u007A' === 'z' //true Unicode 码 \u不简写必须写4个 \uxxxx
'\x7A' === 'z' //true 16进制Unicode 码  一个char占一个字节8位，而16进制一位对应4个二进制位，所以一个char字符用两个16进制位就可以了
'\u{7A}' === 'z' // true \u简写方式
```

## codePointAt()
utf-8 (8-bit Unicode Transformation Format) 下 js 用3个字节表示一个汉字

```js
var s = "𠮷";

s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```
ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。
```js
let s = '𠮷a';

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97
```
总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。


codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。
```js
let s = '𠮷a';

s.codePointAt(0).toString(16) // "20bb7"
s.codePointAt(2).toString(16) // "61"
```
## fromCodePoint
ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。
```js
String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
```

## for of 循环

```js
let s = 'Hello ES6';
for (let char of s) {
  console.log(char);
}
// 'H'
// 'e'
// 'l'
// 'l'
// 'o'
// ' '
// 'E'
// 'S'
// '6'
```

## at()  (提案)
ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。

```js
'abc'.charAt(0) // 'a'
'𠮷'.charAt(0)  // '\uD842'
```

目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。
```js
'abc'.at(0) // 'a'
'𠮷'.at(0)  // '𠮷'
```

## normalize()

```js
'\u01D1'==='\u004F\u030C' //false

'\u01D1'.length // 1
'\u004F\u030C'.length // 2
```

```js
'\u01D1'.normalize() === '\u004F\u030C'.normalize()
// true
```

## includes(), startsWith(), endsWith()

  includes()：返回布尔值，表示是否找到了参数字符串。

  startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。

  endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。


## repeat(),padStart(),padEnd()

  repeat方法返回一个新字符串，表示将原字符串重复n次。
```js
  '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
  '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"

  'x'.padEnd(5, 'ab') // 'xabab'
  'x'.padEnd(4, 'ab') // 'xaba'
```

## 模板字符串

```js
  let name = 'Bob', time = 'today';
  `Hello ${name}, how are you ${time}?`

  let string = ` I love \`js\` `;
  let a = 1;
  let b = 2;
  let result =  `a plus b equal to ${a+b}`

```
### 引用模板字符串本身
```js
    let strFnValue = 'return' + '`Hello ${name}`'

    let sayHello = new Function('name',strFnValue);
```

## 模版编译

```js
  let template = `
  <ul>
    <% for(let i = 0; i < arr.length ; i++ ) {%>
    <li> <%=arr[i]%> </li>
    <% } %>
  </ul>
  `
  //以下省略
```

## 标签模板

```js
alert`123`;
//登同于
alert(123);
```

```js
let a = 5;
let b = 10;

function tag(one,two,three){
  console.log(arguments)
}
tag`Hello ${a+b} world ${a*b}`;
```



